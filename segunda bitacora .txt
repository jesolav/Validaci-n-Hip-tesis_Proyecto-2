identificación de valores nulos 
1. Identificar Valores Nulos en track_in_competition 👍
Fórmula:
SELECT
  COUNTIF(track_id IS NULL) AS null_track_id,
  COUNTIF(in_apple_playlists IS NULL) AS null_in_apple_playlists,
  COUNTIF(in_apple_charts IS NULL) AS null_in_apple_charts,
  COUNTIF(in_deezer_playlists IS NULL) AS null_in_deezer_playlists,
  COUNTIF(in_deezer_charts IS NULL) AS null_in_deezer_charts,
  COUNTIF(in_shazam_charts IS NULL) AS null_in_shazam_charts
FROM `proyecto-hipotesis-427017.hipotesis.track_in_competition`;


Para qué sirve:
* Esta fórmula cuenta los valores nulos en las columnas track_id, in_apple_playlists, in_apple_charts, in_deezer_playlists, in_deezer_charts, y in_shazam_charts de la tabla track_in_competition.
Resultado:
* null_in_shazam_charts = 50




1.1. Identificar Valores Nulos en track_in_spotify 👍
Fórmula:
SELECT
 COUNTIF(track_id IS NULL) AS null_track_id,
 COUNTIF(track_name IS NULL) AS null_track_name,
 COUNTIF(artist_s__name IS NULL) AS null_artist_s__name,
 COUNTIF(artist_count IS NULL) AS null_artist_count,
 COUNTIF(released_year IS NULL) AS null_released_year,
 COUNTIF(released_month IS NULL) AS null_released_month,
 COUNTIF(released_day IS NULL) AS null_released_day,
 COUNTIF(in_spotify_playlists IS NULL) AS null_in_spotify_playlists,
 COUNTIF(in_spotify_charts IS NULL) AS null_in_spotify_charts,
 COUNTIF(streams IS NULL) AS null_streams
FROM `proyecto-hipotesis-427018.hipotesis.track_in_spotify`;




Para qué sirve:
* Esta fórmula cuenta los valores nulos en las columnas track_id, track_name, artists_name, artist_count, released_year, released_month, released_day, in_spotify_playlists, in_spotify_charts, y streams de la tabla track_in_spotify.
Resultado:
* No hay valores nulos en ninguna de las columnas especificadas (todos los conteos de nulos son 0).
 1.2) Identificar Valores Nulos en track_technical 👍
Fórmula:
SELECT
    COUNTIF(track_id IS NULL) AS null_track_id,
    COUNTIF(bpm IS NULL) AS null_bpm,
    COUNTIF(key IS NULL) AS null_key,
    COUNTIF(mode IS NULL) AS null_mode,
    COUNTIF(`danceability_%` IS NULL) AS null_danceability,
    COUNTIF(`valence_%` IS NULL) AS null_valence,
    COUNTIF(`energy_%` IS NULL) AS null_energy,
    COUNTIF(`acousticness_%` IS NULL) AS null_acousticness,
    COUNTIF(`instrumentalness_%` IS NULL) AS null_instrumentalness,
    COUNTIF(`liveness_%` IS NULL) AS null_liveness,
    COUNTIF(`speechiness_%` IS NULL) AS null_speechiness
FROM `proyecto-hipotesis-427017.hipotesis.track_technical`;
Para qué sirve:
* Esta fórmula cuenta los valores nulos en las columnas track_id, bpm, key, mode, danceability_%, valence_%, energy_%, acousticness_%, instrumentalness_%, liveness_%, y speechiness_% de la tabla track_technical.


Resultado:
* null_key = 95


manejo de valores nulos. —-
Revisado, se mantienen los valores nulos
👍
identificacion de duplicados 
. Identificación de Duplicados en track_in_spotify 👍
Consulta:


SELECT
  track_name,
  artist_s__name,
  COUNT(*) AS cantidad
FROM `proyecto-hipotesis-427017.hipotesis.track_in_spotify`
GROUP BY
  track_name,
  artist_s__name
HAVING
  COUNT(*) > 1;


Propósito:
Esta consulta identifica las combinaciones duplicadas de track_name y artists_name en la tabla track_in_spotify. Agrupa las filas por track_name y artists_name y cuenta cuántas veces aparece cada combinación. Luego, filtra los resultados para mostrar solo aquellas combinaciones que aparecen más de una vez.
Resultado:
track_name
	artists_name
	cantidad
	SNAP
	Rosa Linn
	2
	About Damn Time
	Lizzo
	2
	Take My Breath
	The Weeknd
	2
	SPIT IN MY FACE!
	ThxSoMch
	2
	2. Identificación de Duplicados en track_in_competition 👍
Consulta:


SELECT
  track_id,
  COUNT(*) AS cantidad
FROM `proyecto-hipotesis-427017.hipotesis.track_in_competition`
GROUP BY
  track_id
HAVING
  COUNT(*) > 1;
Propósito:
Esta consulta identifica los track_id duplicados en la tabla track_in_competition. Agrupa las filas por track_id y cuenta cuántas veces aparece cada uno. Luego, filtra los resultados para mostrar solo aquellos track_id que aparecen más de una vez.
Resultado:
No hay valores duplicados en la tabla track_in_competition.
________________


3. Identificación de Duplicados en track_technical 👍
Consulta:
SELECT
  track_id,
  COUNT(*) AS cantidad
FROM `proyecto-hipotesis-427017.hipotesis.track_technical`
GROUP BY
  track_id
HAVING
  COUNT(*) > 1;


Propósito:
Esta consulta identifica los track_id duplicados en la tabla track_technical. Agrupa las filas por track_id y cuenta cuántas veces aparece cada uno. Luego, filtra los resultados para mostrar solo aquellos track_id que aparecen más de una vez.
Resultado:
No hay valores duplicados en la tabla track_technical.


Manejo de duplicados 👍
2.1.1) manejo duplicados track_in_spotify 
Propósito:
Esta consulta elimina duplicados en la tabla track_in_spotify, manteniendo solo la fila con el mayor número de reproducciones (streams) y, en caso de empate, la mayor presencia en las listas de Spotify (in_spotify_charts) para cada combinación de track_name y 


CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.track_in_spotify` AS
WITH ranked_tracks AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY track_name, artist_s__name
      ORDER BY streams DESC, in_spotify_charts DESC
    ) AS rn
  FROM `proyecto-hipotesis-427017.hipotesis.track_in_spotify`
)
SELECT
  track_id,
  track_name,
  artist_s__name,
  artist_count,
  released_year,
  released_month,
  released_day,
  in_spotify_playlists,
  in_spotify_charts,
  streams
FROM ranked_tracks
WHERE rn = 1;








1. 2.1.1 Esta consulta verifica que los duplicados se han manejado correctamente, mostrando todas las filas de track_in_spotify para las canciones específicas mencionadas.
SELECT *
FROM `proyecto-hipotesis-427018.hipotesis.track_in_spotify`
WHERE track_name IN ('About Damn Time', 'SNAP', 'SPIT IN MY FACE!', 'Take My Breath');


Identificar y manejar datos fuera del alcance del análisis 👍
3. Exclusión de Variables en track_technical y crear nueva tabla
3.1 Consulta:
CREATE OR REPLACE TABLE `proyecto-hipotesis-426418.hipotesis.track_technical` AS
SELECT
  * EXCEPT (key, mode)
FROM
  `proyecto-hipotesis-426418.hipotesis.track_technical`;


Variables Excluidas:
* key: Clave musical de la canción.
* mode: Modo de la canción (mayor o menor).


4. Identificar y manejar datos discrepantes en variables categóricas


utilizando comandos de manejo de string como LIKE o REGEXP.
4.1 Consulta Utilizada:
CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.track_in_spotify` AS
SELECT
  track_id,
  REGEXP_REPLACE(track_name, r'[^a-zA-Z0-9\s]', '') AS track_name,
  REGEXP_REPLACE(artist_s__name, r'[^a-zA-Z0-9\s]', '') AS artist_s__name,
  artist_count,
  released_year,
  released_month,
  released_day,
  in_spotify_playlists,
  in_spotify_charts,
  streams
FROM
  `proyecto-hipotesis-427018.hipotesis.track_in_spotify`


Esta consulta reemplaza  la tabla track_in_spotify en la que los nombres de las canciones (track_name) y los nombres de los artistas (artists_name) se han limpiado, eliminando todos los caracteres especiales, dejando solo letras, números y espacios. Se incluyen todas las columnas originales de la tabla track_in_spotify.


5. Identificar y manejar datos discrepantes en variables numéricas 👍
 Utilizar comandos como MAX, MIN y AVG para identificar valores discrepantes en variables numéricas

5.1 Tabla track_technical


Al verificar que las columnas relevantes ya están en el tipo de dato INTEGER, podemos proceder directamente con los cálculos.


CREATE TABLE `proyecto-hipotesis-427018.hipotesis.estadisticas_track_technical` AS (
  SELECT
    'bpm' AS Variable,
    MAX(bpm) AS Valor_Maximo,
    MIN(bpm) AS Valor_Minimo,
    ROUND(AVG(bpm), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'danceability_%' AS Variable,
    MAX(`danceability_%`) AS Valor_Maximo,
    MIN(`danceability_%`) AS Valor_Minimo,
    ROUND(AVG(`danceability_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'valence_%' AS Variable,
    MAX(`valence_%`) AS Valor_Maximo,
    MIN(`valence_%`) AS Valor_Minimo,
    ROUND(AVG(`valence_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'energy_%' AS Variable,
    MAX(`energy_%`) AS Valor_Maximo,
    MIN(`energy_%`) AS Valor_Minimo,
    ROUND(AVG(`energy_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'acousticness_%' AS Variable,
    MAX(`acousticness_%`) AS Valor_Maximo,
    MIN(`acousticness_%`) AS Valor_Minimo,
    ROUND(AVG(`acousticness_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'instrumentalness_%' AS Variable,
    MAX(`instrumentalness_%`) AS Valor_Maximo,
    MIN(`instrumentalness_%`) AS Valor_Minimo,
    ROUND(AVG(`instrumentalness_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'liveness_%' AS Variable,
    MAX(`liveness_%`) AS Valor_Maximo,
    MIN(`liveness_%`) AS Valor_Minimo,
    ROUND(AVG(`liveness_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`
  UNION ALL
  SELECT
    'speechiness_%' AS Variable,
    MAX(`speechiness_%`) AS Valor_Maximo,
    MIN(`speechiness_%`) AS Valor_Minimo,
    ROUND(AVG(`speechiness_%`), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427018.hipotesis.track_technical`);






Propósito:
Esta consulta crea una nueva tabla estadisticas_track_technical para identificar los valores máximo, mínimo y promedio de track_technical por cada una de las variables.
Resultado: 


Variable
	Valor_Maximo
	Valor_Minimo
	Valor_Promedio
	speechiness_%
	64
	2
	10.13
	instrumentalness_%
	91
	0
	1.58
	danceability_%
	96
	23
	66.97
	acousticness_%
	97
	0
	27.06
	valence_%
	97
	4
	51.43
	liveness_%
	97
	3
	18.21
	energy_%
	97
	9
	64.28
	bpm
	206
	65
	122.54
	5.2 Tabla track_in_competition


Verificamos que las columnas in_apple_playlists, in_apple_charts, in_deezer_playlists, in_deezer_charts e in_shazam_charts ya son de tipo INTEGER, son adecuadas para nuestros cálculos.

CREATE TABLE `proyecto-hipotesis-427017.hipotesis.estadisticas_track_in_competition` AS (
  SELECT
    'in_apple_playlists' AS Variable,
    MAX(in_apple_playlists) AS Valor_Maximo,
    MIN(in_apple_playlists) AS Valor_Minimo,
    ROUND(AVG(in_apple_playlists), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427017.hipotesis.track_in_competition`
  UNION ALL
  SELECT
    'in_apple_charts' AS Variable,
    MAX(in_apple_charts) AS Valor_Maximo,
    MIN(in_apple_charts) AS Valor_Minimo,
    ROUND(AVG(in_apple_charts), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427017.hipotesis.track_in_competition`
  UNION ALL
  SELECT
    'in_deezer_playlists' AS Variable,
    MAX(in_deezer_playlists) AS Valor_Maximo,
    MIN(in_deezer_playlists) AS Valor_Minimo,
    ROUND(AVG(in_deezer_playlists), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427017.hipotesis.track_in_competition`
  UNION ALL
  SELECT
    'in_deezer_charts' AS Variable,
    MAX(in_deezer_charts) AS Valor_Maximo,
    MIN(in_deezer_charts) AS Valor_Minimo,
    ROUND(AVG(in_deezer_charts), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427017.hipotesis.track_in_competition`
  UNION ALL
  SELECT
    'in_shazam_charts' AS Variable,
    MAX(in_shazam_charts) AS Valor_Maximo,
    MIN(in_shazam_charts) AS Valor_Minimo,
    ROUND(AVG(in_shazam_charts), 2) AS Valor_Promedio
  FROM
    `proyecto-hipotesis-427017.hipotesis.track_in_competition`);






Propósito:
Esta consulta crea una nueva tabla estadisticas_track_in_competition para identificar los valores máximo, mínimo y promedio de track_in_competition por cada una de las variables.
Resultado: 


Variable
	Valor_Maximo
	Valor_Minimo
	Valor_Promedio
	in_apple_playlists
	672
	0
	67.81
	in_shazam_charts
	1451
	0
	60.0
	in_apple_charts
	275
	0
	51.91
	in_deezer_charts
	58
	0
	2.67
	in_deezer_playlists
	12367
	0
	385.19
	

6.1 se ejecutó una consulta para identificar los valores en la columna streams que no podían ser convertidos a números, asegurando que todos los valores fueran numéricos.
Consulta:
SELECT DISTINCT streams
FROM `proyecto-hipotesis-427018.hipotesis.track_in_spotify`
WHERE SAFE_CAST(streams AS INT64) IS NULL;
Resultado: 
Se identifica valor no numérico en columna streams:


BPM110KeyAModeMajorDanceability53Valence75Energy69Acousticness7Instrumentalness0Liveness17Speechiness3
	

5.3) Tabla track_in_spotify 


Esta tabla cuenta con una columna streams con valores no numéricos, por lo que se procede a:


Limpieza de datos: Se eliminan los caracteres no numéricos y se reemplazan las cadenas vacías con nulos en las columnas relevantes.
Conversión a enteros: Los valores limpios se convierten a enteros de 64 bits.
Cálculo de estadísticas: Se calculan el valor máximo, mínimo y promedio para cada columna.
Combinación de resultados: Los resultados de las tres subconsultas se combinan en una sola tabla utilizando UNION ALL.
Creación de tabla: Se crea la tabla estadisticas_track_in_spotify con los resultados combinados.




CREATE TABLE `proyecto-hipotesis-427017.hipotesis.estadisticas_track_in_spotify` AS (SELECT
 'in_spotify_playlists' AS Variable,
 MAX(in_spotify_playlists) AS Valor_Maximo,
 MIN(in_spotify_playlists) AS Valor_Minimo,
 ROUND(AVG(in_spotify_playlists), 2) AS Promedio
FROM
 `proyecto-hipotesis-427017.hipotesis.track_in_spotify`
UNION ALL
SELECT
 'in_spotify_charts' AS Variable,
 MAX(in_spotify_charts) AS Valor_Maximo,
 MIN(in_spotify_charts) AS Valor_Minimo,
 ROUND(AVG(in_spotify_charts), 2) AS Promedio
FROM
 `proyecto-hipotesis-427017.hipotesis.track_in_spotify`
UNION ALL
SELECT
 'streams' AS Variable,
 MAX(SAFE_CAST(streams AS INT64)) AS Valor_Maximo,
 MIN(SAFE_CAST(streams AS INT64)) AS Valor_Minimo,
 ROUND(AVG(SAFE_CAST(streams AS FLOAT64)), 2) AS Promedio
FROM
 `proyecto-hipotesis-427017.hipotesis.track_in_spotify`
WHERE
 SAFE_CAST(streams AS INT64) IS NOT NULL)






	

	

	

	Variable
	Valor_Maximo
	Valor_Minimo
	Promedio
	in_spotify_playlists
	52898
	31
	5207.28
	streams
	3703895074
	2762
	514336542.0
	in_spotify_charts
	147
	0
	12.06
	



La consulta genera una tabla con estadísticas básicas (máximo, mínimo y promedio) para tres variables de interés (in_spotify_playlists, in_spotify_charts, y streams) en la tabla track_in_spotify. Utiliza la unión (UNION ALL) para combinar los resultados de cada variable en una única salida y emplea SAFE_CAST para manejar de forma segura la conversión de la variable streams a tipo numérico.


Crear nuevas variables
7.1_track_in_spotify_release_date
 En la hoja “track_in_spotify Utilizando las columnas released_year, released_month y released_day, combinamos estas columnas en una nueva columna release_date con el formato aaaa-mm-dd.
Consulta para Crear la Variable de Fecha de Lanzamiento Completa:


CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.track_in_spotify` AS
SELECT
  track_id,
  track_name,
  artist_s__name AS artists_name,
  artist_count,
  released_year,
  released_month,
  released_day,
  in_spotify_playlists,
  in_spotify_charts,
  streams,
  CAST(CONCAT(CAST(released_year AS STRING), '-', 
              LPAD(CAST(released_month AS STRING), 2, '0'), '-', 
              LPAD(CAST(released_day AS STRING), 2, '0')) AS DATE) AS release_date
FROM
  `proyecto-hipotesis-427017.hipotesis.track_in_spotify`;






7.2.1_track_in_competition_nueva_columna


CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.track_in_competition_updated` AS
SELECT
  c.track_id,
  c.in_apple_playlists,
  c.in_apple_charts,
  c.in_deezer_playlists,
  c.in_deezer_charts,
  c.in_shazam_charts,
  s.total_playlists
FROM
  `proyecto-hipotesis-427017.hipotesis.track_in_competition` c
LEFT JOIN
  `proyecto-hipotesis-427017.hipotesis.track_in_spotify_total_playlists` s
ON
  c.track_id = s.track_id;








(TABLA ANEXA NO TOMAR PARA CALCULOS)
CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.track_in_spotify_total_playlists` AS
SELECT
  s.track_id,
  s.track_name,
  s.artists_name,
  s.artist_count,
  s.released_year,
  s.released_month,
  s.released_day,
  s.in_spotify_playlists,
  c.in_apple_playlists,
  c.in_deezer_playlists,
  (s.in_spotify_playlists + c.in_apple_playlists + c.in_deezer_playlists) AS total_playlists,
  s.streams,
  CAST(CONCAT(CAST(s.released_year AS STRING), '-', 
              LPAD(CAST(s.released_month AS STRING), 2, '0'), '-', 
              LPAD(CAST(s.released_day AS STRING), 2, '0')) AS DATE) AS release_date
FROM
  `proyecto-hipotesis-427018.hipotesis.track_in_spotify` s
LEFT JOIN
  `proyecto-hipotesis-427018.hipotesis.track_in_competition` c
ON
  s.track_id = c.track_id;






8. Unir tablas


crear la vista (view) con los datos limpios de cada tabla.
1. Crear Vista para track_in_competition_with_total


CREATE OR REPLACE VIEW `proyecto-hipotesis-426418.hipotesis.view_track_in_competition_with_total` AS
SELECT
  track_id,
  in_apple_playlists,
  in_apple_charts,
  in_deezer_playlists,
  in_deezer_charts,
  in_shazam_charts,
  total_playlist_participation
FROM
  `proyecto-hipotesis-426418.hipotesis.track_in_competition_with_total`;
2. crear vista para .track_in_spotify_date_playlists


Durante el proceso de unir tablas en BigQuery, surgió un error debido a que las columnas track_id tenían tipos de datos diferentes (INTEGER en una tabla y STRING en otra). Este tipo de incompatibilidad impide la comparación y unión directa de columnas.
Solución
Para resolver este problema, se convirtió el tipo de dato de la columna track_id de INTEGER a STRING en todas las tablas antes de realizar la unión. Esto se hizo utilizando la función CAST en SQL, que permite cambiar el tipo de dato de una columna.




8. UNIR TABLAS: 
Con las anteriores  vistas creadas que se detallan en la imagen, se procedió a unir las tablas utilizando LEFT JOIN
Resultado :se crea una nueva tabla con todos los datos unificados llamada “unified_track_data¨ 


CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_unificada` AS
SELECT
  s.track_id,
  s.track_name,
  s.artists_name,
  s.artist_count,
  s.released_year,
  s.released_month,
  s.released_day,
  s.in_spotify_playlists,
  s.in_spotify_charts,
  s.streams,
  s.release_date,
  c.in_apple_playlists,
  c.in_apple_charts,
  c.in_deezer_playlists,
  c.in_deezer_charts,
  c.in_shazam_charts,
  c.total_playlists AS total_playlists,
  t.bpm,
  t.`danceability_%`,
  t.`valence_%`,
  t.`energy_%`,
  t.`acousticness_%`,
  t.`instrumentalness_%`,
  t.`liveness_%`,
  t.`speechiness_%`
FROM
  `proyecto-hipotesis-427017.hipotesis.track_in_spotify` s
LEFT JOIN
  `proyecto-hipotesis-427017.hipotesis.track_in_competition_updated` c
ON
  s.track_id = c.track_id
LEFT JOIN
  `proyecto-hipotesis-427017.hipotesis.track_technical` t
ON
  s.track_id = t.track_id;






Construir tablas auxiliares
CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.track_in_spotify_clean` AS
SELECT
 track_id,
 track_name,
 artist_s__name,
 artist_count,
 released_year,
 released_month,
 released_day,
 in_spotify_playlists,
 in_spotify_charts,
 SAFE_CAST(streams AS INT64) AS streams -- Convertir streams a INT64
FROM `proyecto-hipotesis-427018.hipotesis.track_in_spotify`
WHERE SAFE_CAST(streams AS INT64) IS NOT NULL; -- Filtrar solo los valores convertibles




9_solo_artist
CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.total_canciones_solo_artists` AS
WITH solo_artists AS (
  SELECT
    artists_name,
    COUNT(track_id) AS total_canciones
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_unificada`
  WHERE
    artist_count = 1
  GROUP BY
    artists_name
)
SELECT
  *
FROM
  solo_artists;


WITH solo_artists AS (...): Define una tabla temporal llamada solo_artists que selecciona el nombre del artista y cuenta el número de canciones (track_id) donde artist_count es igual a 1.
* SELECT artists_name, COUNT(track_id) AS total_canciones: Selecciona el nombre del artista y cuenta el número de canciones.
* FROM ...: Especifica la tabla tabla_unificada como la fuente de datos.
* WHERE artist_count = 1: Filtra las filas donde artist_count es igual a 1, indicando que el artista es solista.
* GROUP BY artists_name: Agrupa los resultados por el nombre del artista.
SELECT * FROM solo_artists;: Selecciona todos los datos de la tabla temporal solo_artists para crear la tabla final total_canciones_solo_artists.


CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.total_canciones_solo_artists` AS
WITH solo_artists AS (
 SELECT
   artists_name,
   COUNT(track_id) AS total_canciones
 FROM
   `proyecto-hipotesis-427018.hipotesis.tabla_unificada`
 WHERE
   artist_count = 1
 GROUP BY
   artists_name
)
SELECT
 *
FROM
 solo_artists;


visualizar los duplicados. 




WITH duplicates AS (
  SELECT
    track_id,
    COUNT(*) AS count
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
  GROUP BY
    track_id
  HAVING
    COUNT(*) > 1
)
SELECT
  a.*
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz` a
JOIN
  duplicates d
ON
  a.track_id = d.track_id
ORDER BY
  a.track_id


da como resultado esto: 




track_id
	track_name
	1367281
	Enemy from the series Arcane League of Legends
	1367281
	Enemy from the series Arcane League of Legends
	1519987
	Enemy with JID from the series Arcane League of Legends
	1519987
	Enemy with JID from the series Arcane League of Legends
	1726395
	Boys a liar Pt 2
	1726395
	Boys a liar Pt 2
	2817956
	Boys a liar
	2817956
	Boys a liar
	4002890
	A Holly Jolly Christmas Single Version
	4002890
	A Holly Jolly Christmas Single Version
	6909746
	White Christmas
	6909746
	White Christmas
	



guarde la consulta como: viasualizacion_duplicados_v2


CONSULTA ELIMINAR UN DUPLICADO


CREATE OR REPLACE TABLE `proyecto-hipotesis-427018.hipotesis.tabla_matriz` AS
WITH ranked AS (
  SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY track_id ORDER BY track_id) AS rn
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
)
SELECT
  *
FROM
  ranked
WHERE
  rn = 1




Esta consulta elimina el primer duplicado que encuentre y pasa de 954 canciones a 948. 




correlación stream y playlist 


SELECT CORR(total_playlists, streams) AS correlation_value
FROM `proyecto-hipotesis-427018.hipotesis.tabla_matriz`


resultado 


  

Interpretación del Resultado
* 0.7832: Esta es una correlación positiva fuerte. No es perfecta (que sería 1), pero es bastante alta, lo que sugiere que hay una relación lineal significativa entre las dos variables.
Segunda interpretación:
Correlación Positiva Fuerte: El signo positivo indica que existe una relación directa entre las dos variables. Esto significa que, en general, a medida que aumenta el número de listas de reproducción (total_playlists) en las que aparece una canción, también tiende a aumentar el número de reproducciones (streams).
1. Magnitud Fuerte: El valor del coeficiente (0.7832) es cercano a 1, lo que sugiere una correlación bastante fuerte. En otras palabras, el número de listas de reproducción en las que aparece una canción es un factor importante que influye en su número de reproducciones.
Interpretación Gráfica:
Si visualizas esta relación en un gráfico de dispersión, probablemente verás los puntos formando una nube que asciende de izquierda a derecha, siguiendo una tendencia lineal bastante clara.
Consideraciones Adicionales:
* Relación Causal: Aunque la correlación es fuerte, no podemos afirmar que aparecer en más listas de reproducción cause directamente un aumento en las reproducciones. Es posible que haya otros factores que influyan en ambas variables, como la calidad de la canción, la promoción, etc.
* Datos Atípicos (Outliers): Siempre es importante examinar si hay valores atípicos que puedan estar distorsionando la relación observada.
* Análisis Adicional: Para comprender mejor esta relación, podrías realizar análisis más detallados, como examinar la correlación en diferentes géneros musicales o períodos de tiempo.
Conclusión:
En resumen, el coeficiente de correlación de 0.7832 indica una relación positiva fuerte entre total_playlists y streams. Esto sugiere que las canciones que aparecen en más listas de reproducción tienden a tener más reproducciones, aunque es importante tener en cuenta que esta es solo una asociación y no necesariamente una relación causal directa.
crear gráfico para visualizar correlación playlist y streams en power bi 
1. en py 
2. en valores arrastrar streams y total playlist y seleccionar no resumir luego colocar la fórmula.
fórmula: 
import matplotlib.pyplot as plt
# Los datos son cargados automáticamente por Power BI en el dataframe 'dataset'
# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
plt.scatter(dataset['total_playlists'], dataset['streams'], alpha=0.5)
plt.title('Relación entre Total Playlists y Streams')
plt.xlabel('Total Playlists')
plt.ylabel('Streams')
plt.grid(True)
plt.show()


resultado: 


*   Interpretación del Gráfico
   * Eje X (Total Playlists): Representa el número total de playlists en las que se encuentra cada canción.
   * Eje Y (Streams): Representa el número de streams de cada canción.
   * Puntos en el Gráfico: Cada punto en el gráfico representa una canción. La dispersión de los puntos muestra la relación entre el número de playlists y el número de streams.







Correlación entre streams y danceability. 
SELECT CORR(streams, danceability_percentage) AS correlation_value
FROM `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
  

-0.1056: Esta es una correlación negativa muy débil. Indica que hay muy poca relación lineal entre las dos variables. Cuando una variable aumenta, la otra tiende a disminuir ligeramente, pero esta relación no es fuerte ni significativa.


Segunda interpretacion(ppt)
Un coeficiente de correlación de -0.1056 entre streams y danceability_percentage nos indica lo siguiente:
   1. Correlación Negativa Débil: El signo negativo indica que existe una relación inversa entre las dos variables. Esto significa que, en general, a medida que aumenta el porcentaje de "danceability" de una canción, tiende a disminuir ligeramente el número de reproducciones (streams).
   2. Magnitud Débil: El valor absoluto del coeficiente (0.1056) es cercano a cero, lo que sugiere que la relación es bastante débil. En otras palabras, el porcentaje de "danceability" no es un factor muy determinante en el número de reproducciones de una canción. Hay otros factores que probablemente influyen más en la popularidad de una canción.
  



Interpretación Gráfica:
Si visualizas esta relación en un gráfico de dispersión, probablemente verás los puntos dispersos sin un patrón lineal muy claro. Podría haber una ligera tendencia descendente, pero no sería muy pronunciada.
Consideraciones Adicionales:
   * Otros Factores: Es importante recordar que este coeficiente solo mide la relación lineal entre estas dos variables específicas. Hay muchos otros factores que pueden influir en la popularidad de una canción, como el género musical, la promoción, la calidad de la producción, etc.
   * Datos Atípicos (Outliers): La presencia de valores atípicos puede afectar el coeficiente de correlación. Sería útil examinar tu conjunto de datos para identificar y analizar posibles valores atípicos que puedan estar distorsionando la relación observada.
   * Análisis Adicional: Si deseas profundizar en esta relación, podrías considerar realizar análisis más detallados, como segmentar los datos por género musical o período de tiempo para ver si la correlación varía en diferentes contextos.
Conclusión:
En resumen, el coeficiente de correlación de -0.1056 sugiere una relación negativa débil entre streams y danceability_percentage. Esto significa que, si bien hay una tendencia a que las canciones con mayor "danceability" tengan menos reproducciones, esta relación no es muy fuerte y hay otros factores que influyen más en la popularidad de una canción.












🟥 5.3 Aplicar técnica de análisis
Analizar las categorías creadas a través de los cuartiles para las características de la canción en relación con la variable streams
Aplicar Segmentación:
Acousticness
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_acousticness` AS
WITH Quartiles AS (
  SELECT
    track_id,
    acousticness_percentage,
    streams,
    NTILE(4) OVER (ORDER BY acousticness_percentage / 100) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categorias AS (
  SELECT
    acousticness_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categorias
GROUP BY
  categoria
ORDER BY
  categoria;




Categoría
	Promedio Streams
	Alto
	491296878.53488362
	Bajo
	537365626.383966
	

Explicación Breve: (ACTUALIZAR CON VALORES)
En esta tabla se presentan los promedios de streams agrupados en dos categorías basadas en el porcentaje de acousticness de las canciones. Las canciones fueron clasificadas en categorías 'Alto' y 'Bajo' según sus valores de acousticness_percentage utilizando cuartiles. La categoría 'Alto' incluye los cuartiles 3 y 4, mientras que la categoría 'Bajo' incluye los cuartiles 1 y 2. El análisis muestra que las canciones con un acousticness_percentage bajo tienen un promedio de streams más alto (537,365,626.38) en comparación con aquellas con un acousticness_percentage alto (491,307,457.62).




Instrumentalness
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_instrumentalness` AS
WITH Quartiles AS (
  SELECT
    track_id,
    instrumentalness_percentage,
    streams,
    NTILE(4) OVER (ORDER BY instrumentalness_percentage) AS cuartil
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
),
categorias AS (
  SELECT
    instrumentalness_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categorias
GROUP BY
  categoria
ORDER BY
  categoria;




Categoría
	Promedio Streams
	Alto
	273051003.64482009
	Bajo
	755151066.93881822
	

Explicación Breve: (ACTUALIZAR CON VALORES)
En este análisis, hemos categorizado las canciones según su porcentaje de instrumentalidad (instrumentalness_percentage) utilizando cuartiles. Las canciones se dividen en dos categorías: alto y bajo.
   * Bajo: Canciones que caen en los dos primeros cuartiles (1 y 2) en términos de porcentaje de instrumentalidad.
   * Alto: Canciones que caen en los dos últimos cuartiles (3 y 4).
Los resultados muestran que las canciones con un menor porcentaje de instrumentalidad (bajo) tienen un promedio de streams significativamente mayor (757,300,189.0907) en comparación con las canciones con un mayor porcentaje de instrumentalidad (alto), que tienen un promedio de 271,372,894.91139233 streams. Esto sugiere que las canciones menos instrumentales tienden a ser más populares en términos de streams.
Liveness
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_liveness` AS
WITH Quartiles AS (
  SELECT
    track_id,
    liveness_percentage,
    streams,
    NTILE(4) OVER (ORDER BY liveness_percentage) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categorias AS (
  SELECT
    liveness_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categorias
GROUP BY
  categoria
ORDER BY
  categoria;




Categoría
	Promedio Streams
	Alto
	490908045.25792795
	Bajo
	537753639.33755267
	

Explicación Breve: (ACTUALIZAR CON VALORES)
   * Alto: Las canciones con una mayor liveness_percentage (es decir, aquellas que se encuentran en los cuartiles 3 y 4) tienen un promedio de streams de aproximadamente 491 millones.
   * Bajo: Las canciones con una menor liveness_percentage (es decir, aquellas que se encuentran en los cuartiles 1 y 2) tienen un promedio de streams de aproximadamente 538 millones.
Esto sugiere que, en términos de liveness, las canciones con valores más bajos de esta característica tienden a tener un mayor promedio de streams en comparación con las canciones con valores más altos.
Speechiness
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_speechiness` AS
WITH Quartiles AS (
  SELECT
    track_id,
    speechiness_percentage,
    streams,
    NTILE(4) OVER (ORDER BY speechiness_percentage) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categorias AS (
  SELECT
    speechiness_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categorias
GROUP BY
  categoria
ORDER BY
  categoria;






Categoría
	Promedio Streams
	Alto
	447116624.43974632
	Bajo
	581452673.19198322
	

Explicación Breve: (ACTUALIZAR CON VALORES)
En este análisis, hemos categorizado las canciones según su porcentaje de speechiness utilizando cuartiles. Las canciones se dividen en dos categorías: alto y bajo.
   * Bajo: Canciones que caen en los dos primeros cuartiles (1 y 2) en términos de porcentaje de speechiness.
   * Alto: Canciones que caen en los dos últimos cuartiles (3 y 4).
Los resultados muestran que las canciones con un menor porcentaje de speechiness (bajo) tienen un promedio de streams significativamente mayor (581,452,673.19) en comparación con las canciones con un mayor porcentaje de speechiness (alto), que tienen un promedio de 447,220,410.81 streams. Esto sugiere que las canciones con menos elementos hablados tienden a ser más populares en términos de streams.


Danceability
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_danceability` AS
WITH Quartiles AS (
  SELECT
    danceability_percentage,
    streams,
    NTILE(4) OVER (ORDER BY danceability_percentage) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categories AS (
  SELECT
    danceability_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categories
GROUP BY
  categoria;




Categoría
	Promedio Streams
	Alto
	471308505.52431291
	Bajo
	471308505.52431291
	

Explicación Breve: (ACTUALIZAR CON VALORES)
Las canciones clasificadas como "Bajo" en danceability tienen un promedio de streams de 558,025,586.51.
Las canciones clasificadas como "Alto" en danceability tienen un promedio de streams de 470,647,497.49.
Este resultado sugiere que las canciones con menor danceability tienen, en promedio, más streams que aquellas con mayor danceability.


Energy
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_energy` AS
WITH Quartiles AS (
  SELECT
    track_id,
    energy_percentage,
    streams,
    NTILE(4) OVER (ORDER BY energy_percentage / 100) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categorias AS (
  SELECT
    energy_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categorias
GROUP BY
  categoria
ORDER BY
  categoria;






Categoría
	Promedio Streams
	Alto
	490775726.72515857
	Bajo
	537885678.71729958
	

Explicación Breve: (ACTUALIZAR CON VALORES)
En este análisis, hemos segmentado las canciones en dos categorías basadas en los cuartiles de la variable energy_percentage, que indica el porcentaje de energía en la canción. Los resultados indican que:
   * Las canciones con un porcentaje de energía clasificado como "alto" tienen un promedio de aproximadamente 490 millones de streams.
   * Las canciones con un porcentaje de energía clasificado como "bajo" tienen un promedio de aproximadamente 539 millones de streams.
Estos resultados sugieren que, en promedio, las canciones con un porcentaje de energía más bajo tienden a tener más streams que aquellas con un porcentaje de energía más alto.
Valence
CREATE OR REPLACE TABLE `proyecto-hipotesis-427017.hipotesis.tabla_valence` AS
WITH Quartiles AS (
  SELECT
    valence_percentage,
    streams,
    NTILE(4) OVER (ORDER BY valence_percentage) AS cuartil
  FROM
    `proyecto-hipotesis-427017.hipotesis.tabla_matriz`
),
categories AS (
  SELECT
    valence_percentage,
    streams,
    cuartil,
    CASE
      WHEN cuartil IN (1, 2) THEN 'bajo'
      WHEN cuartil IN (3, 4) THEN 'alto'
    END AS categoria
  FROM
    Quartiles
)
SELECT
  categoria,
  AVG(streams) AS promedio_streams
FROM
  categories
GROUP BY
  categoria;






Categoría
	Promedio Streams
	Alto
	542222252.628692
	Bajo
	486429984.58139539
	

Explicación Breve: (ACTUALIZAR CON VALORES)


El análisis de valence (porcentaje que representa la positividad o felicidad de una canción) y su relación con los streams se ha segmentado en dos categorías:
Bajo: Incluye canciones con un valor de valence en el cuartil 1 (los valores más bajos) y en el cuartil 2 (valores medio-bajos).
Alto: Incluye canciones con un valor de valence en el cuartil 3 (valores medio-altos) y en el cuartil 4 (los valores más altos).
Interpretación
Categoría Bajo: Las canciones clasificadas como de valence bajo (menos positivas o felices) tienen un promedio de streams de aproximadamente 543 millones.
Categoría Alto: Las canciones clasificadas como de valence alto (más positivas o felices) tienen un promedio de streams de aproximadamente 486 millones.
Conclusión
Las canciones con valence bajo parecen tener más éxito en términos de streams en comparación con las canciones con valence alto. Esto puede indicar que las canciones con tonos menos positivos o felices son más populares o tienen más streams en Spotify.
Validar las hipótesis levantadas a través de la correlación y scatter plot
En este hito, buscamos responder las hipótesis planteadas por la discográfica:
   1. Las canciones con un mayor BPM (Beats Por Minuto) tienen más éxito en términos de streams en Spotify

Coeficiente correlación bpm y streams:-0.0023050669108400381
Consulta en sql:
fórmula 
SELECT
 CORR(BPM, streams) AS correlation_value
FROM
 `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
resultado: 
   
El valor sugiere una correlación negativa muy débil entre los BPM de una canción y la cantidad de streams. En otras palabras, parece que no hay una relación significativa entre el ritmo de una canción y su éxito en términos de streams. 
Lo graficamos en power bi con python
# El código siguiente, que crea un dataframe y quita las filas duplicadas, siempre se ejecuta y actúa como un preámbulo del script:
# dataset = pandas.DataFrame(total_playlists, streams)
# dataset = dataset.drop_duplicates()
# Pegue o escriba aquí el código de script:
import matplotlib.pyplot as plt
# Los datos son cargados automáticamente por Power BI en el dataframe 'dataset'
# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
plt.scatter(dataset['bpm'], dataset['streams'], alpha=0.5)
plt.title('Relación entre bpm y Streams')
plt.xlabel('bpm')
plt.ylabel('Streams')
plt.grid(True)
plt.show()


      2. Las canciones más populares en el ranking de Spotify también tienen un comportamiento similar en otras plataformas como Deezer
Primero analizaremos la correlación variable deezer_charts y spotify_charts 
SELECT
  CORR(in_spotify_charts, in_deezer_charts) AS correlation_value
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
resultado: 
0.60481440133235
La correlación de 0.60 indica una relación positiva moderada entre las variables in_spotify_charts y in_deezer_charts. Esto significa que las canciones que son populares en Spotify tienden a ser también populares en Deezer, aunque no es una correlación extremadamente fuerte.

Evidencia Visual:
  
Los gráficos de barras muestran que algunas canciones, como "As It Was" y "Flowers", se encuentran en los primeros lugares de popularidad en ambas plataformas, lo que respalda la hipótesis.
Sin embargo, también hay canciones que muestran discrepancias en su popularidad entre las plataformas. Por ejemplo, "Seven (feat. Latto - Explicit)" es la canción más popular en Spotify, pero no aparece en el top 15 de Deezer. Por otro lado, "Flowers" es la canción más popular en Deezer, pero ocupa el tercer lugar en Spotify.

Conclusión:
En general, los datos apoyan parcialmente la hipótesis de que las canciones más populares en Spotify también tienen un comportamiento similar en Deezer.
Sin embargo, la correlación moderada y las discrepancias observadas en los gráficos sugieren que existen otros factores que influyen en la popularidad de una canción en cada plataforma, además de su popularidad en Spotify.

      3. La presencia de una canción en un mayor número de playlists se relaciona con un mayor número de streams
Para esta hipótesis, analizamos los valores promedios por cada cuartil de la categoría streams: 
  

El análisis revela una clara tendencia: las canciones en más playlists tienen más reproducciones, respaldando la hipótesis de que la presencia en playlists aumenta la popularidad de una canción. Esto se debe probablemente a una mayor visibilidad, el efecto "bola de nieve" y los algoritmos de recomendación.
Sin embargo, es importante recordar que la correlación no implica causalidad, y otros factores podrían estar influyendo.
SELECT CORR(total_playlists, streams) AS correlation_value
FROM `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
  





Evidencia Visual
  

Código Python:
import matplotlib.pyplot as plt
import numpy as np  # Importa la biblioteca NumPy
# Los datos son cargados automáticamente por Power BI en el dataframe 'dataset'
# Crear el gráfico de dispersión con mejoras
plt.figure(figsize=(10, 6))  # Ajusta el tamaño si es necesario
# Personalizar el estilo de los puntos (opcional)
plt.scatter(dataset['total_playlists'], dataset['streams'], alpha=0.5, color='skyblue', edgecolors='black')  # Color y borde
# Añadir títulos y etiquetas más descriptivos
plt.title('Relación entre Presencia en Playlists y Streams', fontsize=14)
plt.xlabel('Total de Playlists', fontsize=12)
plt.ylabel('Streams (en millones)', fontsize=12)  # Puedes ajustar la unidad si es necesario
# Añadir línea de tendencia
z = np.polyfit(dataset['total_playlists'], dataset['streams'], 1)
p = np.poly1d(z)
plt.plot(dataset['total_playlists'], p(dataset['total_playlists']), "r--")  # Línea roja discontinua
# Mostrar el gráfico
plt.grid(True, linestyle='--')  # Cuadrícula con líneas discontinuas
plt.tight_layout()  # Ajusta el diseño para evitar superposiciones
plt.show()


El gráfico de dispersión muestra una correlación positiva moderada entre la suma de streams y la suma de total_playlists. Esto significa que, en general, las canciones que aparecen en más playlists tienden a tener un mayor número de streams.
Sin embargo, la dispersión de los puntos sugiere que la relación no es perfecta y que hay otros factores que influyen en el número de streams además de la presencia en playlists. Por ejemplo, la calidad de la canción, el género musical y la popularidad del artista también pueden jugar un papel importante.
Además, se puede observar que hay algunas canciones atípicas (outliers) que tienen un número muy alto de streams pero aparecen en relativamente pocas playlists. Esto podría indicar que estas canciones se han vuelto populares por otros medios, como la promoción en redes sociales o el boca a boca.
En general, el gráfico respalda la hipótesis de que la presencia de una canción en un mayor número de playlists se relaciona con un mayor número de streams. Sin embargo, es importante tener en cuenta que esta relación no es determinista y que hay otros factores que también influyen en la popularidad de una canción.
      4. Los artistas con un mayor número de canciones en Spotify tienen más streams *

Coeficiente de correlación: 0.77893082035123706
Consulta big query:
SELECT
  CORR(total_songs, total_streams) AS correlation_value
FROM (
  SELECT
    artists_name,
    COUNT(track_id) AS total_songs,
    SUM(streams) AS total_streams
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
  GROUP BY
    artists_name
);
Para este análisis agrupamos el total de playlists en spotify por artista y lo comparamos con el total de streams:






# El código siguiente, que crea un dataframe y quita las filas duplicadas, siempre se ejecuta y actúa como un preámbulo del script:


# dataset = pandas.DataFrame(total_playlists, streams)
# dataset = dataset.drop_duplicates()


# Pegue o escriba aquí el código de script:


import matplotlib.pyplot as plt




# Los datos son cargados automáticamente por Power BI en el dataframe 'dataset'
# Crear el gráfico de dispersión
plt.figure(figsize=(16, 12))
plt.scatter(dataset['in_spotify_playlists'], dataset['streams'], alpha=0.5)
plt.title('Relación entre in_spotify_playlists y Streams')
plt.xlabel('in_spotify_playlists')
plt.ylabel('Streams')
plt.grid(True)
plt.show()
  

783 indica una fuerte relación positiva entre el número de canciones de un artista en Spotify y su número total de reproducciones. Esto sugiere que, en general, los artistas con más canciones en la plataforma tienden a tener más reproducciones.
Posibles explicaciones para esta correlación:
         * Mayor visibilidad: Más canciones pueden aumentar la visibilidad de un artista en Spotify, lo que lleva a más oyentes y reproducciones.
         * Mayor variedad: Una discografía más amplia puede atraer a un público más diverso, aumentando las reproducciones.
         * Popularidad establecida: Los artistas que han lanzado muchas canciones pueden tener una base de fans más grande y leal, lo que resulta en más reproducciones.
Es importante tener en cuenta que:
         * Correlación no implica causalidad: Aunque existe una fuerte relación, esto no significa necesariamente que tener más canciones en Spotify cause directamente más reproducciones. Podrían existir otros factores que influyen en ambas variables.
         * Excepciones: Siempre hay excepciones a la regla. Algunos artistas con menos canciones pueden tener un gran éxito, mientras que otros con muchas canciones pueden no ser tan populares.
En conclusión, el análisis respalda la hipótesis de que existe una relación positiva significativa entre el número de canciones de un artista en Spotify y su número total de reproducciones. Sin embargo, es fundamental considerar que esta es solo una parte del panorama y que otros factores también pueden influir en el éxito de un artista en la plataforma.
         5. Las características de la canción influyen en el éxito en términos de streams en Spotify
SELECT
 CORR(danceability_percentage, streams) AS danceability_corr,
 CORR(valence_percentage, streams) AS valence_corr,
 CORR(energy_percentage, streams) AS energy_corr,
 CORR(acousticness_percentage, streams) AS acousticness_corr,
 CORR(instrumentalness_percentage, streams) AS instrumentalness_corr,
 CORR(liveness_percentage, streams) AS liveness_corr,
 CORR(speechiness_percentage, streams) AS speechiness_corr
FROM
 `proyecto-hipotesis-427018.hipotesis.tabla_matriz`;
  







hipótesis para el año 2023
1)Las canciones con un mayor BPM (Beats Por Minuto) tienen más éxito en términos de streams en Spotify en el año 2023.
SELECT
  CORR(bpm, streams) AS correlation_value
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
WHERE
  released_year = 2023;
  

gráfico en power bi: 
import matplotlib.pyplot as plt


# Filtrar los datos para el año 2023
dataset_2023 = dataset[dataset['released_year'] == 2023]


# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
plt.scatter(dataset_2023['bpm'], dataset_2023['streams'], alpha=0.5)
plt.title('Relación entre BPM y Streams en Spotify en 2023')
plt.xlabel('BPM')
plt.ylabel('Streams')
plt.grid(True)
plt.show()
  



*consulta guardada como: correlacion_bpm_streams_2023
2) Las canciones más populares en el ranking de Spotify también tienen un comportamiento similar en otras plataformas como Deezer (2023).
SELECT
  CORR(in_spotify_charts, in_deezer_charts) AS correlation_value
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
WHERE
  released_year = 2023;
  

*consulta guardada como: correlacion_spotify_deezer_2023
en powerBi
import matplotlib.pyplot as plt


# Filtrar los datos para el año 2023
dataset_2023 = dataset[dataset['released_year'] == 2023]


# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
plt.scatter(dataset_2023['in_spotify_charts'], dataset_2023['in_deezer_charts'], alpha=0.5)
plt.title('Relación entre Popularidad en Spotify y Deezer en 2023')
plt.xlabel('Rank en Spotify')
plt.ylabel('Rank en Deezer')
plt.grid(True)
plt.show()
  



3) La presencia de una canción en un mayor número de playlists se relaciona con un mayor número de streams (año 2023)
SELECT
  CORR(total_playlists, streams) AS correlation_value
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
WHERE
  released_year = 2023;
  

En power bi : 
import matplotlib.pyplot as plt


# Filtrar los datos para el año 2023
dataset_2023 = dataset[dataset['released_year'] == 2023]


# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
plt.scatter(dataset_2023['total_playlists'], dataset_2023['streams'], alpha=0.5)
plt.title('Relación entre el Número de Playlists y Streams en 2023')
plt.xlabel('Total de Playlists')
plt.ylabel('Streams')
plt.grid(True)
plt.show()


  



4)Los artistas con un mayor número de canciones en Spotify tienen más streams
SELECT
  CORR(total_songs, total_streams) AS correlation_value
FROM (
  SELECT
    artists_name,
    COUNT(track_id) AS total_songs,
    SUM(streams) AS total_streams
  FROM
    `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
  WHERE
    released_year = 2023
  GROUP BY
    artists_name
);
  



5) Las características de la canción influyen en el éxito en términos de streams en Spotify
SELECT
  CORR(danceability_percentage, streams) AS danceability_corr,
  CORR(valence_percentage, streams) AS valence_corr,
  CORR(energy_percentage, streams) AS energy_corr,
  CORR(acousticness_percentage, streams) AS acousticness_corr,
  CORR(instrumentalness_percentage, streams) AS instrumentalness_corr,
  CORR(liveness_percentage, streams) AS liveness_corr,
  CORR(speechiness_percentage, streams) AS speechiness_corr
FROM
  `proyecto-hipotesis-427018.hipotesis.tabla_matriz`
WHERE
  released_year = 2023;